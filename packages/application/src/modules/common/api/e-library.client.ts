/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated with ApiClientGenerator, using the NSwag toolchain
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import axios, { AxiosRequestConfig, AxiosPromise, AxiosInstance, CancelToken } from 'axios';
import { injectable, inject, optional, symbolToken } from '@servicetitan/react-ioc';
// @ts-ignore: needed for Date serialization if a DateTime parameter has an Unspecified attribute on it
import moment from 'moment';

interface ClientApiConfig {
    baseUrl: string;
    axios: AxiosInstance;
}

export const BASE_URL_TOKEN_ELibraryApi = symbolToken<string>('BASE_URL_TOKEN', false);
export const AXIOS_TOKEN_ELibraryApi = symbolToken<string>('AXIOS_TOKEN', false);

@injectable()
export class ELibraryApi {
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;
    protected readonly opts: ClientApiConfig;

    constructor(
        @inject(BASE_URL_TOKEN_ELibraryApi) @optional() baseUrl = '',
        @inject(AXIOS_TOKEN_ELibraryApi) @optional() axiosInstance = axios,
    ) {

        this.opts = {
            baseUrl,
            axios: axiosInstance,
        };
    }

    /**
     * @return Signed up
     */
    authController_signUpUser(body: CreateUserDto, cancelToken?: CancelToken): AxiosPromise<void> {
        let url_ = "/auth/signup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = body;

        let options_ = <AxiosRequestConfig>{
            baseURL: this.opts.baseUrl,
            cancelToken,
            data: content_,
            url: url_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.opts.axios.request<void>(options_);
    }

    /**
     * @return Signed in
     */
    authController_signInUser(body: LoginUserDto, cancelToken?: CancelToken): AxiosPromise<void> {
        let url_ = "/auth/signin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = body;

        let options_ = <AxiosRequestConfig>{
            baseURL: this.opts.baseUrl,
            cancelToken,
            data: content_,
            url: url_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.opts.axios.request<void>(options_);
    }

    usersController_getUsers(name: string | undefined, page: number | undefined, pageSize: number | undefined, cancelToken?: CancelToken): AxiosPromise<void> {
        let url_ = "/users?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            baseURL: this.opts.baseUrl,
            cancelToken,
            url: url_,
            method: "GET",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.opts.axios.request<void>(options_);
    }

    usersController_getUserById(id: number, cancelToken?: CancelToken): AxiosPromise<UserEntity> {
        let url_ = "/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            baseURL: this.opts.baseUrl,
            cancelToken,
            url: url_,
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.opts.axios.request<UserEntity>(options_);
    }

    usersController_editCategory(id: number, body: EditUserDto, cancelToken?: CancelToken): AxiosPromise<UserEntity> {
        let url_ = "/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = body;

        let options_ = <AxiosRequestConfig>{
            baseURL: this.opts.baseUrl,
            cancelToken,
            data: content_,
            url: url_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.opts.axios.request<UserEntity>(options_);
    }

    usersController_deleteCategory(id: number, cancelToken?: CancelToken): AxiosPromise<void> {
        let url_ = "/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            baseURL: this.opts.baseUrl,
            cancelToken,
            url: url_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.opts.axios.request<void>(options_);
    }

    booksController_addBook(body: CreateBookDto, cancelToken?: CancelToken): AxiosPromise<void> {
        let url_ = "/books";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = body;

        let options_ = <AxiosRequestConfig>{
            baseURL: this.opts.baseUrl,
            cancelToken,
            data: content_,
            url: url_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.opts.axios.request<void>(options_);
    }

    categoryController_addCategory(body: CreateCategoryDto, cancelToken?: CancelToken): AxiosPromise<void> {
        let url_ = "/category";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = body;

        let options_ = <AxiosRequestConfig>{
            baseURL: this.opts.baseUrl,
            cancelToken,
            data: content_,
            url: url_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.opts.axios.request<void>(options_);
    }

    categoryController_getCategories(name: string | undefined, cancelToken?: CancelToken): AxiosPromise<void> {
        let url_ = "/category?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            baseURL: this.opts.baseUrl,
            cancelToken,
            url: url_,
            method: "GET",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.opts.axios.request<void>(options_);
    }

    categoryController_getCategoryById(id: number, cancelToken?: CancelToken): AxiosPromise<CategoryEntity> {
        let url_ = "/category/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            baseURL: this.opts.baseUrl,
            cancelToken,
            url: url_,
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.opts.axios.request<CategoryEntity>(options_);
    }

    categoryController_editCategory(id: number, body: EditCategoryDto, cancelToken?: CancelToken): AxiosPromise<CategoryEntity> {
        let url_ = "/category/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = body;

        let options_ = <AxiosRequestConfig>{
            baseURL: this.opts.baseUrl,
            cancelToken,
            data: content_,
            url: url_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.opts.axios.request<CategoryEntity>(options_);
    }

    categoryController_deleteCategory(id: number, cancelToken?: CancelToken): AxiosPromise<void> {
        let url_ = "/category/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            baseURL: this.opts.baseUrl,
            cancelToken,
            url: url_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.opts.axios.request<void>(options_);
    }
}

export class CreateUserDto implements ICreateUserDto {
    email!: string;
    password!: string;
    name!: string;
    phoneNumber!: string;

    [key: string]: any;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.email = _data["email"];
            this.password = _data["password"];
            this.name = _data["name"];
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["email"] = this.email;
        data["password"] = this.password;
        data["name"] = this.name;
        data["phoneNumber"] = this.phoneNumber;
        return data;
    }
}

export interface ICreateUserDto {
    email: string;
    password: string;
    name: string;
    phoneNumber: string;

    [key: string]: any;
}

export class LoginUserDto implements ILoginUserDto {
    email!: string;
    password!: string;

    [key: string]: any;

    constructor(data?: ILoginUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoginUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginUserDto {
    email: string;
    password: string;

    [key: string]: any;
}

export class UserEntity implements IUserEntity {
    email!: string;
    password!: string;
    name!: string;
    role!: UserEntityRole;
    phoneNumber!: string;
    id!: number;
    created_at!: Date;
    updated_at!: Date;

    [key: string]: any;

    constructor(data?: IUserEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.email = _data["email"];
            this.password = _data["password"];
            this.name = _data["name"];
            this.role = _data["role"];
            this.phoneNumber = _data["phoneNumber"];
            this.id = _data["id"];
            this.created_at = _data["created_at"] ? new Date(_data["created_at"].toString()) : <any>undefined;
            this.updated_at = _data["updated_at"] ? new Date(_data["updated_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserEntity {
        data = typeof data === 'object' ? data : {};
        let result = new UserEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["email"] = this.email;
        data["password"] = this.password;
        data["name"] = this.name;
        data["role"] = this.role;
        data["phoneNumber"] = this.phoneNumber;
        data["id"] = this.id;
        data["created_at"] = this.created_at ? this.created_at.toISOString() : <any>undefined;
        data["updated_at"] = this.updated_at ? this.updated_at.toISOString() : <any>undefined;
        return data;
    }
}

export interface IUserEntity {
    email: string;
    password: string;
    name: string;
    role: UserEntityRole;
    phoneNumber: string;
    id: number;
    created_at: Date;
    updated_at: Date;

    [key: string]: any;
}

export class EditUserDto implements IEditUserDto {
    name!: string;
    phoneNumber!: string;

    [key: string]: any;

    constructor(data?: IEditUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): EditUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["phoneNumber"] = this.phoneNumber;
        return data;
    }
}

export interface IEditUserDto {
    name: string;
    phoneNumber: string;

    [key: string]: any;
}

export class CreateBookDto implements ICreateBookDto {
    title!: string;
    description!: string;
    author!: string;
    categoryId!: string;

    [key: string]: any;

    constructor(data?: ICreateBookDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.title = _data["title"];
            this.description = _data["description"];
            this.author = _data["author"];
            this.categoryId = _data["categoryId"];
        }
    }

    static fromJS(data: any): CreateBookDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBookDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["title"] = this.title;
        data["description"] = this.description;
        data["author"] = this.author;
        data["categoryId"] = this.categoryId;
        return data;
    }
}

export interface ICreateBookDto {
    title: string;
    description: string;
    author: string;
    categoryId: string;

    [key: string]: any;
}

export class CreateCategoryDto implements ICreateCategoryDto {
    name!: string;

    [key: string]: any;

    constructor(data?: ICreateCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        return data;
    }
}

export interface ICreateCategoryDto {
    name: string;

    [key: string]: any;
}

export class CategoryEntity implements ICategoryEntity {
    name!: string;
    books!: BookEntity[];
    id!: number;
    created_at!: Date;
    updated_at!: Date;

    [key: string]: any;

    constructor(data?: ICategoryEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.books = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            if (Array.isArray(_data["books"])) {
                this.books = [] as any;
                for (let item of _data["books"])
                    this.books!.push(BookEntity.fromJS(item));
            }
            this.id = _data["id"];
            this.created_at = _data["created_at"] ? new Date(_data["created_at"].toString()) : <any>undefined;
            this.updated_at = _data["updated_at"] ? new Date(_data["updated_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CategoryEntity {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        if (Array.isArray(this.books)) {
            data["books"] = [];
            for (let item of this.books)
                data["books"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["created_at"] = this.created_at ? this.created_at.toISOString() : <any>undefined;
        data["updated_at"] = this.updated_at ? this.updated_at.toISOString() : <any>undefined;
        return data;
    }
}

export interface ICategoryEntity {
    name: string;
    books: BookEntity[];
    id: number;
    created_at: Date;
    updated_at: Date;

    [key: string]: any;
}

export class BookEntity implements IBookEntity {
    title!: string;
    description!: string;
    author!: string;
    count!: number;
    holdCount!: number;
    category!: CategoryEntity;
    id!: number;
    created_at!: Date;
    updated_at!: Date;

    [key: string]: any;

    constructor(data?: IBookEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.category = new CategoryEntity();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.title = _data["title"];
            this.description = _data["description"];
            this.author = _data["author"];
            this.count = _data["count"];
            this.holdCount = _data["holdCount"];
            this.category = _data["category"] ? CategoryEntity.fromJS(_data["category"]) : new CategoryEntity();
            this.id = _data["id"];
            this.created_at = _data["created_at"] ? new Date(_data["created_at"].toString()) : <any>undefined;
            this.updated_at = _data["updated_at"] ? new Date(_data["updated_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BookEntity {
        data = typeof data === 'object' ? data : {};
        let result = new BookEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["title"] = this.title;
        data["description"] = this.description;
        data["author"] = this.author;
        data["count"] = this.count;
        data["holdCount"] = this.holdCount;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["created_at"] = this.created_at ? this.created_at.toISOString() : <any>undefined;
        data["updated_at"] = this.updated_at ? this.updated_at.toISOString() : <any>undefined;
        return data;
    }
}

export interface IBookEntity {
    title: string;
    description: string;
    author: string;
    count: number;
    holdCount: number;
    category: CategoryEntity;
    id: number;
    created_at: Date;
    updated_at: Date;

    [key: string]: any;
}

export class EditCategoryDto implements IEditCategoryDto {
    name!: string;

    [key: string]: any;

    constructor(data?: IEditCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): EditCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        return data;
    }
}

export interface IEditCategoryDto {
    name: string;

    [key: string]: any;
}

export enum UserEntityRole {
    User = "User",
    Admin = "Admin",
}